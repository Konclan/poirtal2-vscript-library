//  ________________________________________________________________________
//
//                               raycast_beam.nut
//
//  Script code for raycast beam method.
//  For use with raycast_beam* instances.
//  
//  ________________________________________________________________________
//
//  Global entities:
//
//      @raycast_beammaker: template for beam entities.
//
//  ________________________________________________________________________
//
//  Beams data structure:
//
//  {
//      beams = [all sources of effect beams]
//      targets = [all targets of effect beams]
//      sprites = [all sprites generated by effect beams]
//  }
//
//  ________________________________________________________________________
//


IncludeScript("utils.nut");

BEAMS <- [];

function raycast_beam_init() {

    // Find our maker ent and set position variables
    local maker = Entities.FindByName(null, "@raycast_beammaker");
    local beam_pos = maker.GetOrigin() + (maker.GetLeftVector() * -16);
    local target_pos = maker.GetOrigin() + (maker.GetLeftVector() * -32);

    // We need a lot of beams. Instead of copying them a bunch of times in hammer
    // we use a template and spawn a bunch after map load. Makes life easier.
    // Would love to just spawn in the ents in the script
    // but env_laser destroys itself without keyvalues sadly.
    for (local i = 0; i<16; i++) {
        
        // Spawn our ents from a template
        maker.SpawnEntity();

        // Find our ents
        local beam = find_thing("env_laser", beam_pos);
        local target = find_thing("info_target", target_pos);
        local sprite = find_thing("env_sprite", target_pos);

        // Debug code, ignore
        // if (beam) { printl( "Beam: " + beam.GetName()); } else { printl( "No Beam :(" ); }
        // if (target) { printl( "Target: " + target.GetName()); } else { printl( "No Target :(" ); }
        // if (sprite) { printl( "Sprite: " + sprite.GetName()); } else { printl( "No Sprite :(" ); }
        
        // printl("Maker Pos: " + maker.GetOrigin());
        // printl("Beam Pos: " + beam_pos);
        // printl("Beam True Pos: " + Entities.FindByName(null, "@raycast_beam").GetOrigin());

        // Rename our ents
        beam.__KeyValueFromString("targetname", beam.GetName() + i);
        target.__KeyValueFromString("targetname", target.GetName() + i);
        sprite.__KeyValueFromString("targetname", target.GetName() + "_sprite" + i);

        beam.__KeyValueFromString("LaserTarget", target.GetName());

        // Move our ents out of the way
        beam.SetOrigin(beam.GetOrigin() + beam.GetUpVector() * -16);
        target.SetOrigin(target.GetOrigin() + target.GetUpVector() * -16);
        sprite.SetOrigin(target.GetOrigin() + sprite.GetUpVector() * -16);

        // Save ents to table
        BEAMS.append({beam = beam, target = target, sprite = sprite});
    }
}

function raycast_beam_trace(start_vec, angle, portals) {
    raycast_beam_position_emitter(BEAMS[0], start_vec, angle);
}

function raycast_beam_position_emitter(ents, origin, angle) {
    local end_vec = origin + rotate(Vector(16384, 0, 0), angle)
    ents.beam.SetOrigin(origin);
    ents.target.SetOrigin(end_vec);
}